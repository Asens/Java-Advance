---
description: 对象的可达性分析和垃圾回收算法
---
# 垃圾回收

Java中，内存由虚拟机管理，控制着回收什么，什么时候回收，怎么回收。

在栈中内存的随线程产生和分配，销毁而回收，在堆中，需要制定一系列策略来判断该回收哪些区域，以及何时回收。

## 可达性分析

主流的做法是通过可达性分析来判断对象是否存活。存在一些根节点（GC Roots）作为起始点，从这些节点向下搜索，通过的路径为引用链，当对象与GC Roots间不存在任何引用链时，该对象不再被需要。

GC Root包括：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区常量引用的对象
- Native方法引用的对象

**引用**

Java为引用提供了四种级别，除了强引用之外，还有其他引用，在垃圾回收时有着不同的表现

- 强引用：默认的引用方式，引用还在，对象就不会被回收
- 软引用（SoftReference）：垃圾回收后内存不够用会在软引用中再回收一次，还没有足够内存，则内存溢出
- 弱引用（WeekReference）：垃圾收集时，回收
- 虚引用：最弱的关系，当对象被收集时，可以获得通知

**标记**

在对象进行可达性分析后如果没有GC引用链，则被第一次标记

之后有线程调用`finalize()`方法，如果重新进入引用链，则不会回收，否则，被回收

## 垃圾回收算法

### 标记-清除算法

最基础的算法，标记就是上述过程，完成标记之后清除对应的内存空间，它的不足有2点：

- 效率：标记和清除效率都不高
- 空间：清楚之后会产生大量的空间碎片，在有大的对象时，可能会提前触发GC

### 复制算法

将内存分为2块，一块内存用完了，就把存活的对象移动到另一块，然后全部清除之前的一块。另一块内存用完之后，同理。

优点是不用考虑内存碎片，但是缺点就是内存只有原来的一半

### 标记-整理算法

和标记-清除类似，但是清除有所不同，将以存活对象移动到一端，然后对其他区域进行清除。

### 分代收集算法

把堆分为新生代和老年代，根据分代的特点使用不同的收集算法。

**新生代**

在新生代每次垃圾收集时都有大量的对象死去,少量的对象存活，比较适合复制算法。

但是并不是上面所说的1:1，通常采用的是1个Eden区，2个Survivor，默认8:1:1的比例，新的对象默认进入Eden区，当内存不足时，进行新生代GC，存活的对象进入1个Survivor区，完成之后新的对象继续分配进入Eden区，再次发生GC时，Eden区的和Survivor区的存活对象进入另一个Survivor区

当对象很大时，会直接进入老年代，包括分配阶段和回收阶段

当对象存活很多轮时，也会进入老年代

**老年代**

